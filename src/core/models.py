"""Core data models for the trading system"""

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any, List, Union

# Optional numpy import for performance
try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False


@dataclass
class OHLCV:
    """Open, High, Low, Close, Volume data point"""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float

    def __post_init__(self):
        """Validate OHLCV data integrity"""
        if self.high < max(self.open, self.close, self.low):
            raise ValueError("High must be >= max(open, close, low)")
        if self.low > min(self.open, self.close, self.high):
            raise ValueError("Low must be <= min(open, close, high)")
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    timestamp: datetime
    symbol: str
    signal_type: SignalType
    price: float
    confidence: float  # 0.0 to 1.0
    strategy_name: str
    metadata: Dict[str, Any]

    def __post_init__(self):
        """Validate signal data"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if self.price <= 0:
            raise ValueError("Price must be positive")


@dataclass
class Trade:
    """Executed trade record"""
    trade_id: str
    entry_time: datetime
    exit_time: Optional[datetime]
    symbol: str
    quantity: float
    entry_price: float
    exit_price: Optional[float]
    pnl: Optional[float]
    commission: float = 0.0  # Default to commission-free trading
    strategy_name: str = ""
    signal_metadata: Dict[str, Any] = None

    def __post_init__(self):
        """Initialize default values"""
        if self.signal_metadata is None:
            self.signal_metadata = {}

    @property
    def is_open(self) -> bool:
        """Check if trade is still open"""
        return self.exit_time is None

    @property
    def duration_hours(self) -> Optional[float]:
        """Calculate trade duration in hours"""
        if self.exit_time is None:
            return None
        return (self.exit_time - self.entry_time).total_seconds() / 3600

    def calculate_pnl(self, current_price: Optional[float] = None) -> float:
        """Calculate P&L for the trade"""
        if self.exit_price is not None:
            # Closed trade
            return (self.exit_price - self.entry_price) * self.quantity - self.commission
        elif current_price is not None:
            # Open trade
            return (current_price - self.entry_price) * self.quantity
        else:
            return 0.0


@dataclass
class PerformanceMetrics:
    """Performance metrics for strategy evaluation"""
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    total_pnl: float
    total_return_pct: float
    max_drawdown: float
    max_drawdown_pct: float
    sharpe_ratio: float
    sortino_ratio: float
    profit_factor: float
    avg_win: float
    avg_loss: float
    largest_win: float
    largest_loss: float
    avg_trade_duration_hours: float
    max_consecutive_wins: int
    max_consecutive_losses: int


@dataclass
class BacktestResult:
    """Complete backtest results"""
    strategy_name: str
    symbol: str
    start_date: datetime
    end_date: datetime
    initial_capital: float
    final_capital: float
    trades: List[Trade]
    equity_curve: List[float]
    performance_metrics: PerformanceMetrics
    signals: List[Signal]


class TimeFrame(Enum):
    """Supported timeframes"""
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAILY = "1d"
    WEEKLY = "1w"
    MONTHLY = "1M"


@dataclass
class MarketData:
    """Container for market data with metadata"""
    symbol: str
    timeframe: TimeFrame
    data: List[OHLCV]
    indicators: Dict[str, Union[List, 'np.ndarray']]
    last_updated: datetime

    def to_arrays(self):
        """Convert OHLCV data to arrays for calculations"""
        if not self.data:
            if HAS_NUMPY:
                return {
                    'timestamp': np.array([]),
                    'open': np.array([]),
                    'high': np.array([]),
                    'low': np.array([]),
                    'close': np.array([]),
                    'volume': np.array([])
                }
            else:
                return {
                    'timestamp': [],
                    'open': [],
                    'high': [],
                    'low': [],
                    'close': [],
                    'volume': []
                }
        
        if HAS_NUMPY:
            return {
                'timestamp': np.array([d.timestamp for d in self.data]),
                'open': np.array([d.open for d in self.data]),
                'high': np.array([d.high for d in self.data]),
                'low': np.array([d.low for d in self.data]),
                'close': np.array([d.close for d in self.data]),
                'volume': np.array([d.volume for d in self.data])
            }
        else:
            return {
                'timestamp': [d.timestamp for d in self.data],
                'open': [d.open for d in self.data],
                'high': [d.high for d in self.data],
                'low': [d.low for d in self.data],
                'close': [d.close for d in self.data],
                'volume': [d.volume for d in self.data]
            }


class StrategyStatus(Enum):
    """Strategy execution status"""
    ACTIVE = "active"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class StrategyConfig:
    """Configuration for strategy execution"""
    strategy_name: str
    parameters: Dict[str, Any]
    symbols: List[str]
    timeframes: List[TimeFrame]
    max_positions: int
    risk_per_trade: float  # Percentage of capital to risk
    status: StrategyStatus
    created_at: datetime
    updated_at: datetime