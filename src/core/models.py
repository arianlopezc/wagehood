"""Core data models for the trading system"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Any, List, Union, TYPE_CHECKING

# Optional numpy import for performance
if TYPE_CHECKING:
    import numpy as np

try:
    import numpy as np

    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False


@dataclass
class OHLCV:
    """Open, High, Low, Close, Volume data point"""

    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float

    def __post_init__(self):
        """Validate OHLCV data integrity"""
        # Use single pass validation for performance
        if self.high < self.open or self.high < self.close or self.high < self.low:
            raise ValueError("High must be >= max(open, close, low)")
        if self.low > self.open or self.low > self.close or self.low > self.high:
            raise ValueError("Low must be <= min(open, close, high)")
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")


class SignalType(Enum):
    """Trading signal types"""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class Signal:
    """Trading signal generated by strategy"""

    timestamp: datetime
    symbol: str
    signal_type: SignalType
    price: float
    confidence: float  # 0.0 to 1.0
    strategy_name: str
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal data"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if self.price <= 0:
            raise ValueError("Price must be positive")


@dataclass
class SignalAnalysisResult:
    """Signal analysis results for strategy evaluation"""

    strategy_name: str
    symbol: str
    start_date: datetime
    end_date: datetime
    signals: List[Signal]
    signal_timestamps: List[datetime] = field(default_factory=list)
    total_signals: int = 0
    buy_signals: int = 0
    sell_signals: int = 0
    hold_signals: int = 0
    avg_confidence: float = 0.0
    signal_frequency: float = 0.0  # signals per day
    metadata: Dict[str, Any] = field(default_factory=dict)


class TimeFrame(Enum):
    """Supported timeframes"""

    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAILY = "1d"
    WEEKLY = "1w"
    MONTHLY = "1M"


@dataclass
class MarketData:
    """Container for market data with metadata"""

    symbol: str
    timeframe: TimeFrame
    data: List[OHLCV]
    indicators: Dict[str, Union[List, "np.ndarray"]]
    last_updated: datetime

    def to_arrays(self) -> Dict[str, Union[List, "np.ndarray"]]:
        """Convert OHLCV data to arrays for calculations"""
        if not self.data:
            empty_array = np.array([]) if HAS_NUMPY else []
            return {
                "timestamp": empty_array.copy() if HAS_NUMPY else [],
                "open": empty_array.copy() if HAS_NUMPY else [],
                "high": empty_array.copy() if HAS_NUMPY else [],
                "low": empty_array.copy() if HAS_NUMPY else [],
                "close": empty_array.copy() if HAS_NUMPY else [],
                "volume": empty_array.copy() if HAS_NUMPY else [],
            }

        # Pre-allocate arrays for better performance
        size = len(self.data)

        if HAS_NUMPY:
            # Pre-allocate numpy arrays
            timestamps = np.empty(size, dtype=object)
            opens = np.empty(size, dtype=np.float64)
            highs = np.empty(size, dtype=np.float64)
            lows = np.empty(size, dtype=np.float64)
            closes = np.empty(size, dtype=np.float64)
            volumes = np.empty(size, dtype=np.float64)

            # Fill arrays using vectorized assignment
            for i, d in enumerate(self.data):
                timestamps[i] = d.timestamp
                opens[i] = d.open
                highs[i] = d.high
                lows[i] = d.low
                closes[i] = d.close
                volumes[i] = d.volume

            return {
                "timestamp": timestamps,
                "open": opens,
                "high": highs,
                "low": lows,
                "close": closes,
                "volume": volumes,
            }
        else:
            # Pre-allocate lists
            timestamps = [None] * size
            opens = [None] * size
            highs = [None] * size
            lows = [None] * size
            closes = [None] * size
            volumes = [None] * size

            # Fill lists
            for i, d in enumerate(self.data):
                timestamps[i] = d.timestamp
                opens[i] = d.open
                highs[i] = d.high
                lows[i] = d.low
                closes[i] = d.close
                volumes[i] = d.volume

            return {
                "timestamp": timestamps,
                "open": opens,
                "high": highs,
                "low": lows,
                "close": closes,
                "volume": volumes,
            }


class StrategyStatus(Enum):
    """Strategy execution status"""

    ACTIVE = "active"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class StrategyConfig:
    """Configuration for strategy execution"""

    strategy_name: str
    parameters: Dict[str, Any]
    symbols: List[str]
    timeframes: List[TimeFrame]
    max_positions: int
    risk_per_trade: float  # Percentage of capital to risk
    status: StrategyStatus
    created_at: datetime
    updated_at: datetime

    def __post_init__(self):
        """Validate configuration"""
        if self.max_positions < 0:
            raise ValueError("max_positions must be non-negative")
        if not 0.0 <= self.risk_per_trade <= 1.0:
            raise ValueError("risk_per_trade must be between 0.0 and 1.0")
