"""Core data models for the trading system"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any, List, Union, TYPE_CHECKING
import sys

# Optional numpy import for performance
if TYPE_CHECKING:
    import numpy as np

try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False


@dataclass
class OHLCV:
    """Open, High, Low, Close, Volume data point"""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float

    def __post_init__(self):
        """Validate OHLCV data integrity"""
        # Use single pass validation for performance
        if self.high < self.open or self.high < self.close or self.high < self.low:
            raise ValueError("High must be >= max(open, close, low)")
        if self.low > self.open or self.low > self.close or self.low > self.high:
            raise ValueError("Low must be <= min(open, close, high)")
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    timestamp: datetime
    symbol: str
    signal_type: SignalType
    price: float
    confidence: float  # 0.0 to 1.0
    strategy_name: str
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal data"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if self.price <= 0:
            raise ValueError("Price must be positive")


@dataclass
class Trade:
    """Executed trade record"""
    trade_id: str
    entry_time: datetime
    exit_time: Optional[datetime]
    symbol: str
    quantity: float
    entry_price: float
    exit_price: Optional[float]
    pnl: Optional[float]
    commission: float = 0.0  # Default to commission-free trading
    strategy_name: str = ""
    signal_metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def is_open(self) -> bool:
        """Check if trade is still open"""
        return self.exit_time is None

    @property
    def duration_hours(self) -> Optional[float]:
        """Calculate trade duration in hours"""
        if self.exit_time is None:
            return None
        return (self.exit_time - self.entry_time).total_seconds() / 3600

    def calculate_pnl(self, current_price: Optional[float] = None) -> float:
        """Calculate P&L for the trade"""
        if self.exit_price is not None:
            # Closed trade - cache the result in pnl field
            if self.pnl is None:
                self.pnl = (self.exit_price - self.entry_price) * self.quantity - self.commission
            return self.pnl
        elif current_price is not None:
            # Open trade - always calculate fresh
            return (current_price - self.entry_price) * self.quantity
        else:
            return 0.0


@dataclass
class PerformanceMetrics:
    """Performance metrics for strategy evaluation"""
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    total_pnl: float
    total_return_pct: float
    max_drawdown: float
    max_drawdown_pct: float
    sharpe_ratio: float
    sortino_ratio: float
    profit_factor: float
    avg_win: float
    avg_loss: float
    largest_win: float
    largest_loss: float
    avg_trade_duration_hours: float
    max_consecutive_wins: int
    max_consecutive_losses: int


@dataclass
class BacktestResult:
    """Complete backtest results"""
    strategy_name: str
    symbol: str
    start_date: datetime
    end_date: datetime
    initial_capital: float
    final_capital: float
    trades: List[Trade]
    equity_curve: List[float]
    performance_metrics: PerformanceMetrics
    signals: List[Signal]


class TimeFrame(Enum):
    """Supported timeframes"""
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAILY = "1d"
    WEEKLY = "1w"
    MONTHLY = "1M"


@dataclass
class MarketData:
    """Container for market data with metadata"""
    symbol: str
    timeframe: TimeFrame
    data: List[OHLCV]
    indicators: Dict[str, Union[List, 'np.ndarray']]
    last_updated: datetime

    def to_arrays(self) -> Dict[str, Union[List, 'np.ndarray']]:
        """Convert OHLCV data to arrays for calculations"""
        if not self.data:
            empty_array = np.array([]) if HAS_NUMPY else []
            return {
                'timestamp': empty_array.copy() if HAS_NUMPY else [],
                'open': empty_array.copy() if HAS_NUMPY else [],
                'high': empty_array.copy() if HAS_NUMPY else [],
                'low': empty_array.copy() if HAS_NUMPY else [],
                'close': empty_array.copy() if HAS_NUMPY else [],
                'volume': empty_array.copy() if HAS_NUMPY else []
            }
        
        # Pre-allocate arrays for better performance
        size = len(self.data)
        
        if HAS_NUMPY:
            # Pre-allocate numpy arrays
            timestamps = np.empty(size, dtype=object)
            opens = np.empty(size, dtype=np.float64)
            highs = np.empty(size, dtype=np.float64)
            lows = np.empty(size, dtype=np.float64)
            closes = np.empty(size, dtype=np.float64)
            volumes = np.empty(size, dtype=np.float64)
            
            # Fill arrays using vectorized assignment
            for i, d in enumerate(self.data):
                timestamps[i] = d.timestamp
                opens[i] = d.open
                highs[i] = d.high
                lows[i] = d.low
                closes[i] = d.close
                volumes[i] = d.volume
            
            return {
                'timestamp': timestamps,
                'open': opens,
                'high': highs,
                'low': lows,
                'close': closes,
                'volume': volumes
            }
        else:
            # Pre-allocate lists
            timestamps = [None] * size
            opens = [None] * size
            highs = [None] * size
            lows = [None] * size
            closes = [None] * size
            volumes = [None] * size
            
            # Fill lists
            for i, d in enumerate(self.data):
                timestamps[i] = d.timestamp
                opens[i] = d.open
                highs[i] = d.high
                lows[i] = d.low
                closes[i] = d.close
                volumes[i] = d.volume
            
            return {
                'timestamp': timestamps,
                'open': opens,
                'high': highs,
                'low': lows,
                'close': closes,
                'volume': volumes
            }


class StrategyStatus(Enum):
    """Strategy execution status"""
    ACTIVE = "active"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class StrategyConfig:
    """Configuration for strategy execution"""
    strategy_name: str
    parameters: Dict[str, Any]
    symbols: List[str]
    timeframes: List[TimeFrame]
    max_positions: int
    risk_per_trade: float  # Percentage of capital to risk
    status: StrategyStatus
    created_at: datetime
    updated_at: datetime
    
    def __post_init__(self):
        """Validate configuration"""
        if self.max_positions < 0:
            raise ValueError("max_positions must be non-negative")
        if not 0.0 <= self.risk_per_trade <= 1.0:
            raise ValueError("risk_per_trade must be between 0.0 and 1.0")